### `Mysql`高级之explain ###

1. `explain`语句的简单使用示例：

   ```mysql
   explain select * from table;
   ```

   `explain`直接使用在正常查询语句前。

2. `explain`之`id`:

   `explain`中的`id`和表的主键有类似之处但意义不同，`explain`结果中的`id`是`select`查询的序列号，包含一组数字，表示查询中执行`select`子句或操作表的顺序，有三种情况：

   1. `id`相同，执行顺序由上至下
   2. `id`不同，如果是子查询，`id`的序号会递增，`id`值越大优先级越高，越先被执行
   3. `id`列中即存在相同的数字又有不同的，那么数字越大的越先执行，相同的`id`顺序执行

3. `explain`之`select_type`：

   `select_type`有以下这些结果：

   1. `SIMPLE`:故名思意，此为简单查询，查询中不包含**子查询**或者`UNION`
   2. `PRIMARY`:查询中若包含任何复杂的子部分，最外层查询则被标记为`PRIMARY`
   3. `SUBQUERY`:在`select`或`WHERE`列表中包含了的子查询
   4. `DERIVED`:在`FROM`列表中包含的子查询被标记为`DERIVED(衍生)`,`MySQL`会递归执行这些子查询，把结果放在临时表中。
   5. `UNION`:若第二个`SELECT`出现在`UNION`之后，则被标记为`UNION`;若`UNION`包含在`FROM`子句的子查询中，外层`SELECT`将被标记为：`DERIVED`。
   6. `UNION RESULT`:从`UION`表获取结果的`SELECT`将会被标记为`UNION RESULT`。

4. `explain`之`type`:

   `type`是访问类型排列，从最好到最差依次是：

   `system`>`const`>`eq_ref`>`ref`>`range`>`index`>`ALL`

   如果能达到`range`或者`ref`级别，那就很好了。

   1. `system`:表中只用一行记录（等于系统表），这是`const`类型的特例，平时不会出现。
   2. `const`:表示通过索引一次就找到了，`const`用于比较`primary key`或者`unique`索引。因为只匹配一行数据，所以很快，如将**主键**置于`where`列表中，`Mysql`就能将该查询转换为一个常量。
   3. `eq_ref`:唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或者唯一索引扫描。
   4. `ref`:非唯一行索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，他返回所有匹配所有匹配某个单值的行，然而，他可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。
   5. `range`:只检索给定范围的行，使用一个索引来选择行，`key`列显示使用了那个索引，一般就是在`WHERE`子句中出现了`between、<、>、in`等，这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部。
   6. `index`:`Full Index Scan`,`index`与`ALL`区别为`index`类型只遍历索引树，这通常比`ALL`快，因为索引文件通常比数据文件小。（**也就是说虽然all和index都是读全表，但是index从索引中读取的，而`all`是从硬盘中读取的）
   7. `ALL`:全表扫描。

5. `explain`之`possible_keys`

   显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出。但不一定被查询实际使用。

6. `explain`之`key`

   实际上使用的索引，如果为`NULL`，则没有使用索引，查询中若使用了覆盖索引，则该索引仅出现在`key`列表中。

7. `explain`之`key_len`：表示索引中使用的字节数，可通过该列计算出查询中使用的索引的长度。在不损失精度的情况下，长度越短越好，也就是说，在相同查询结果的情况下，其长度越短越好。`key_len`显示的值为索引字段的最大可能长度，并非实际使用长度，即`key_len`是根据表定义计算而来的，不是通过表内检索出的。

8. `explain`之`ref`:显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。

9. `explain`之`rows`:根据表统计信息及索引选用情况，大致估算出找到所需记录所需要读取的行数。即每张表有多少行被优化器查询。、

10. `explain`之`Extra`:如果出现：

    1. `using filesort`:这说明`mysql`会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。`Mysql`中无法利用索引完成的排序称为***文件排序***。出现这个结果，说明比较危险。当在复合索引（一般不少于3个字段）查询时跨阶排序，就会出现这种情况。

    2. `using  temporary`:使用了临时表保存中间结果，`Mysql`在对查询结果排序时使用临时表。常见于排序`order by`和分组查询`group by`。这是非常耗时间的，对数据库性能有较大恶劣影响。

    3. `using index`:表示相应的`select`操作中使用了覆盖索引(`Covering Index`),避免了访问表的数据行，效率不错！

       3.1如果同时出现了`using where`,表明索引被用来执行索引键值的查找；

       3.2如果没出现`using where`,表明索引用来读取数据而执行查找动作。

       有关覆盖索引(`Covering Index`):可以理解为就是`select`的数据只用从索引中就能取得，不必读取数据行，`Mysql`可以利用索引返回`select`列表中的字段，而不必根据索引再次读取数据文件，换句话说**`查询列要被所建的索引覆盖`**。如果要使用覆盖索引，一定要注意`select`列表中只取出需要的列，不可`select *`,因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。

    

    

    

